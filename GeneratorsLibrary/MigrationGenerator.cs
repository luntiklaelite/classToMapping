using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GeneratorsLibrary
{
    public class MigrationGenerator
    {
        public static Dictionary<string, string> TypesForMigrations = new Dictionary<string, string>()
        {
            {"short","Int16"},
            {"int","Int32"},
            {"long","Int64"},
            {"float","Single"},
            {"double","Double"},
            {"decimal","Decimal"},
            {"string","String"},
            {"byte","Byte"},
            {"char","StringFixedLength"},
            {"bool","Boolean"},
            {"Guid","Guid"},
            {"DateTime","Date"},
            {"DateTime?","Date"},
        };
        public List<string> NotMappedPropertyNames { get; private set; } = new List<string>()
        {
            "Photos",
            "PhotoableType",
        };
        public string AssemblyName { get; set; }
        public string MappingFileName { get; private set; }
        public string MigrationFileName { get; private set; }
        private CompilationUnitSyntax root;
        private string textForParsing;
        public MigrationGenerator()
        {

        }
        public MigrationGenerator(string assemblyName)
        {
            AssemblyName = assemblyName;
        }
        public void SetParsedTextFromFiles(string[] paths)
        {
            textForParsing = string.Empty;
            foreach (var path in paths)
            {
                textForParsing += File.ReadAllText(path);
            }
            SyntaxTree tree = CSharpSyntaxTree.ParseText(textForParsing);
            root = tree.GetCompilationUnitRoot();
        }
        public void SetParsedTextFromFiles(string path)
        {
            textForParsing = File.ReadAllText(path);
            SyntaxTree tree = CSharpSyntaxTree.ParseText(textForParsing);
            root = tree.GetCompilationUnitRoot();
        }
        public void SetParsedTextFromCode(string csCode)
        {
            textForParsing = csCode;
            SyntaxTree tree = CSharpSyntaxTree.ParseText(textForParsing);
            root = tree.GetCompilationUnitRoot();
        }
        public string GenerateMigration()
        {
            StringBuilder stringBuilder = new StringBuilder();
            var now = DateTime.Now;
            var mainNamespace = root.ChildNodes().OfType<NamespaceDeclarationSyntax>().First();
            var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();
            var enums = root.DescendantNodes().OfType<EnumDeclarationSyntax>();
            var enumNames = enums.Select(e => e.Identifier.ToString()).ToList();
            var mainClass = classes.First();
            var baseList = mainClass.BaseList?.Types.Select(t => t.ToString());
            MigrationFileName = $"Migration{now.Year}{now.Month.ToString("D2")}{now.Day.ToString("D2")}{now.Hour.ToString("D2")}{now.Minute.ToString("D2")}.cs";
            var propertiesWithPredefinedTypes = mainClass.DescendantNodes()
                .OfType<PropertyDeclarationSyntax>()
                .Where(c => c.Parent is ClassDeclarationSyntax)
                .Where(c => c.DescendantNodes().OfType<PredefinedTypeSyntax>().Count() > 0)
                .Where(c => HasSetter(c)); //нужны только свойства, содержащие сеттер
            var propertiesWithCustomTypes = mainClass.DescendantNodes()
                .OfType<PropertyDeclarationSyntax>()
                .Where(c => c.Parent is ClassDeclarationSyntax)
                .Where(c => c.DescendantNodes().OfType<IdentifierNameSyntax>().Count() > 0)
                .Where(c => !NotMappedPropertyNames.Contains(c.Identifier.ToString()))
                .Where(c => HasSetter(c)); //нужны только свойства, содержащие сеттер
            stringBuilder.AppendLine($"//Generated by MigrationGenerator, {now}"); ;
            stringBuilder.AppendLine("using System.Data;");
            stringBuilder.AppendLine("using Migrator.Framework;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();
#warning не реализовано
            return stringBuilder.ToString();
        }

        /// <summary>
        /// Возвращает true, если свойство имеет сеттер
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        private static bool HasSetter(PropertyDeclarationSyntax c)
        {
#warning может не работать с не авто свойствами 
            return c.AccessorList != null &&
                                c.AccessorList.ChildNodes().Select(prop => prop.ToString()).Contains("set;");
        }

        //public static string GetTableNamePrefix(string assemblyName)
        //{
        //    assemblyName.
        //    return;
        //}
    }
}
